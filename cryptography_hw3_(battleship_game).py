# -*- coding: utf-8 -*-
"""Cryptography HW3 (battleship game).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19ezWRoQpoA3rXcX_ZD33xnPhon62F-kL
"""

!pip install Pyfhel

import random
import numpy as np
from Pyfhel import Pyfhel

try:
    from IPython.display import clear_output
except ImportError:
    def clear_output(wait=False):
        print("\n" * 5)


# ---------------------------import random
import numpy as np
from Pyfhel import Pyfhel

# ---------------------------
#  CONSTANTS
# ---------------------------

BOARD_SIZE = 10
SHIP_SIZES = [5, 4, 3, 2, 2]

EMPTY = 0
SHIP = 1
HIT = 2
MISS = 3


# ---------------------------
#  BOARD HELPERS
# ---------------------------

def create_empty_board():
    return [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]


def can_place_ship(board, row, col, size, horizontal):
    if horizontal:
        if col + size > BOARD_SIZE:
            return False
        for c in range(col, col + size):
            if board[row][c] != EMPTY:
                return False
    else:
        if row + size > BOARD_SIZE:
            return False
        for r in range(row, row + size):
            if board[r][col] != EMPTY:
                return False
    return True


def place_ship(board, size):
    placed = False
    while not placed:
        horizontal = random.choice([True, False])
        if horizontal:
            row = random.randint(0, BOARD_SIZE - 1)
            col = random.randint(0, BOARD_SIZE - size)
        else:
            row = random.randint(0, BOARD_SIZE - size)
            col = random.randint(0, BOARD_SIZE - 1)

        if can_place_ship(board, row, col, size, horizontal):
            if horizontal:
                for c in range(col, col + size):
                    board[row][c] = SHIP
            else:
                for r in range(row, row + size):
                    board[r][col] = SHIP
            placed = True


def place_all_ships(board):
    for size in SHIP_SIZES:
        place_ship(board, size)


# ---------------------------
#  HOMOMORPHIC ENCRYPTION
# ---------------------------

def init_he():
    HE = Pyfhel()
    HE.contextGen(scheme="bfv", n=2**14, t_bits=20)
    HE.keyGen()
    return HE


def encrypt_board(HE, board):
    enc = []
    for r in range(BOARD_SIZE):
        row = []
        for c in range(BOARD_SIZE):
            val = np.array([board[r][c]], dtype=np.int64)
            row.append(HE.encryptInt(val))
        enc.append(row)
    return enc


def decrypt_cell(HE, ctxt):
    return int(HE.decryptInt(ctxt)[0])


# ---------------------------
#  PLAYER
# ---------------------------

class Player:
    def __init__(self, name, HE):
        self.name = name
        self.board_plain = create_empty_board()
        place_all_ships(self.board_plain)
        self.board_enc = encrypt_board(HE, self.board_plain)
        self.total_ship_cells = sum(v == SHIP for row in self.board_plain for v in row)
        self.hits_taken = 0

    def all_ships_sunk(self):
        return self.hits_taken >= self.total_ship_cells


# ---------------------------
#  PRINTING
# ---------------------------

def print_board(board, show_ships=True):
    print("    " + " ".join(f"{i+1:2d}" for i in range(BOARD_SIZE)))
    for r in range(BOARD_SIZE):
        label = chr(ord("A") + r)
        row_str = f"{label:2s}  "
        for c in range(BOARD_SIZE):
            cell = board[r][c]
            if cell == EMPTY:
                ch = "."
            elif cell == SHIP:
                ch = "O" if show_ships else "."
            elif cell == HIT:
                ch = "X"
            elif cell == MISS:
                ch = "*"
            else:
                ch = "?"
            row_str += ch + "  "
        print(row_str)


def coords_to_indices(coord: str):
    coord = coord.strip().upper()
    if len(coord) < 2 or len(coord) > 3:
        return None
    row_char = coord[0]
    if not ("A" <= row_char <= "J"):
        return None
    try:
        col = int(coord[1:]) - 1
    except ValueError:
        return None
    if not (0 <= col < BOARD_SIZE):
        return None
    row = ord(row_char) - ord("A")
    return row, col


def show_state(current: Player, opponent: Player, turn: int):
    print("\n" + "=" * 40)
    print(f"TURN {turn} – {current.name}'s turn")
    print("=" * 40)
    print(f"\n{current.name}'s board:")
    print_board(current.board_plain, show_ships=True)

    print(f"\n{opponent.name}'s board (known info):")
    fog = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
    for r in range(BOARD_SIZE):
        for c in range(BOARD_SIZE):
            v = opponent.board_plain[r][c]
            if v in (HIT, MISS):
                fog[r][c] = v
    print_board(fog, show_ships=False)


# ---------------------------
#  TURN LOGIC
# ---------------------------

def take_shot(attacker: Player, defender: Player, HE: Pyfhel):
    print(f"\n--- {attacker.name} is shooting at {defender.name} ---")

    while True:
        shot = input(f"{attacker.name}, enter target (A1–J10), e.g. A5 or J10:\n> ")
        idx = coords_to_indices(shot)
        if idx is None:
            print("Invalid coordinate. Try again.")
            continue
        r, c = idx
        if defender.board_plain[r][c] in (HIT, MISS):
            print("You already shot there, choose another cell.")
            continue
        break

    ctxt_cell = defender.board_enc[r][c]
    ctxt_one = HE.encryptInt(np.array([1], dtype=np.int64))
    ctxt_res = ctxt_cell * ctxt_one
    res = decrypt_cell(HE, ctxt_res)

    if res == SHIP:
        print("HIT!")
        defender.board_plain[r][c] = HIT
        defender.hits_taken += 1
        defender.board_enc[r][c] = HE.encryptInt(np.array([0], dtype=np.int64))
    else:
        print("MISS!")
        defender.board_plain[r][c] = MISS


# ---------------------------
#  MAIN GAME LOOP
# ---------------------------

def main():
    print("=== Battleship with Homomorphic Encryption (Pyfhel BFV) ===")
    print("10x10 boards, ships: 5, 4, 3, 2, 2\n")

    HE = init_he()

    p1_name = input("Enter Player 1 name: ") or "Player1"
    p2_name = input("Enter Player 2 name: ") or "Player2"

    player1 = Player(p1_name, HE)
    player2 = Player(p2_name, HE)

    current = player1
    opponent = player2
    turn = 1

    while True:
        show_state(current, opponent, turn)
        take_shot(current, opponent, HE)

        if opponent.all_ships_sunk():
            print("\n" + "#" * 40)
            print(f"{current.name} WINS! All opponent ships sunk.")
            print("#" * 40)
            print(f"\n{player1.name}'s final board:")
            print_board(player1.board_plain, show_ships=True)
            print(f"\n{player2.name}'s final board:")
            print_board(player2.board_plain, show_ships=True)
            break

        current, opponent = opponent, current
        turn += 1


# START THE GAME
main()

#  CONSTANTS
# ---------------------------

BOARD_SIZE = 10
SHIP_SIZES = [5, 4, 3, 2, 2]

EMPTY = 0
SHIP = 1
HIT = 2
MISS = 3


# ---------------------------
#  HELPER FUNCTIONS
# ---------------------------

def create_empty_board():
    """Create a 10x10 empty board."""
    return [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]


def can_place_ship(board, row, col, size, horizontal):
    """Check if a ship fits without overlapping."""
    if horizontal:
        if col + size > BOARD_SIZE:
            return False
        for c in range(col, col + size):
            if board[row][c] != EMPTY:
                return False
    else:
        if row + size > BOARD_SIZE:
            return False
        for r in range(row, row + size):
            if board[r][col] != EMPTY:
                return False
    return True


def place_ship(board, size):
    """Randomly place a ship of a given size."""
    placed = False
    while not placed:
        horizontal = random.choice([True, False])
        row = random.randint(0, BOARD_SIZE - (1 if horizontal else size))
        col = random.randint(0, BOARD_SIZE - (size if horizontal else 1))

        if can_place_ship(board, row, col, size, horizontal):
            if horizontal:
                for c in range(col, col + size):
                    board[row][c] = SHIP
            else:
                for r in range(row, row + size):
                    board[r][col] = SHIP
            placed = True


def place_all_ships(board):
    for size in SHIP_SIZES:
        place_ship(board, size)


# ---------------------------
#   HOMOMORPHIC ENCRYPTION
# ---------------------------

def init_he():
    """Initialize Pyfhel homomorphic encryption context."""
    HE = Pyfhel()
    HE.contextGen(scheme='bfv', n=2**14, t_bits=20)
    HE.keyGen()
    return HE


def encrypt_board(HE, board):
    """Encrypt the whole board cell-by-cell."""
    enc_board = []
    for r in range(BOARD_SIZE):
        row = []
        for c in range(BOARD_SIZE):
            value = np.array([board[r][c]], dtype=np.int64)
            row.append(HE.encryptInt(value))
        enc_board.append(row)
    return enc_board


def decrypt_cell(HE, ctxt):
    """Decrypt a single ciphertext number."""
    return int(HE.decryptInt(ctxt)[0])


# ---------------------------
#   PLAYER CLASS
# ---------------------------

class Player:
    def __init__(self, name, HE):
        self.name = name
        self.board_plain = create_empty_board()
        place_all_ships(self.board_plain)

        # Encrypt the player board
        self.board_enc = encrypt_board(HE, self.board_plain)

        # Count ship cells to track game over
        self.total_ship_cells = sum(
            1 for row in self.board_plain for val in row if val == SHIP
        )
        self.hits_taken = 0

    def all_ships_sunk(self):
        return self.hits_taken >= self.total_ship_cells


# ---------------------------
#  PRINTING FUNCTIONS
# ---------------------------

def print_board(board, show_ships=True):
    """Pretty printing of boards."""
    print("    " + " ".join(f"{i+1:2d}" for i in range(BOARD_SIZE)))
    for r in range(BOARD_SIZE):
        label = chr(ord('A') + r)
        row_str = f"{label:2s}  "
        for c in range(BOARD_SIZE):
            cell = board[r][c]
            if cell == EMPTY:
                ch = '.'
            elif cell == SHIP:
                ch = 'O' if show_ships else '.'
            elif cell == HIT:
                ch = 'X'
            elif cell == MISS:
                ch = '*'
            else:
                ch = '?'
            row_str += ch + "  "
        print(row_str)


def coords_to_indices(coord):
    """Convert coordinates like 'A5' → (0, 4)."""
    coord = coord.strip().upper()
    if len(coord) < 2 or len(coord) > 3:
        return None
    row = ord(coord[0]) - ord('A')
    if not (0 <= row < BOARD_SIZE):
        return None
    try:
        col = int(coord[1:]) - 1
    except ValueError:
        return None
    if not (0 <= col < BOARD_SIZE):
        return None
    return row, col


def print_game_state(current, opponent):
    clear_output(wait=True)
    print(f"=== {current.name}'s turn ===")
    print("\nYour board:")
    print_board(current.board_plain, show_ships=True)

    print(f"\n{opponent.name}'s board (your view):")
    hidden = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
    for r in range(BOARD_SIZE):
        for c in range(BOARD_SIZE):
            if opponent.board_plain[r][c] in (HIT, MISS):
                hidden[r][c] = opponent.board_plain[r][c]
    print_board(hidden, show_ships=False)


# ---------------------------
#  SHOOTING LOGIC
# ---------------------------

def take_shot(attacker, defender, HE):
    print(f"\n--- {attacker.name} is shooting at {defender.name} ---")

    while True:
        shot = input(f"{attacker.name}, enter target (A1–J10): ")
        idx = coords_to_indices(shot)
        if idx is None:
            print("Invalid coordinate. Try again.")
            continue
        r, c = idx
        if defender.board_plain[r][c] in (HIT, MISS):
            print("You already shot here.")
            continue
        break

    encrypted_cell = defender.board_enc[r][c]
    encrypted_one = HE.encryptInt(np.array([1], dtype=np.int64))

    encrypted_result = encrypted_cell * encrypted_one
    result = decrypt_cell(HE, encrypted_result)

    if result == SHIP:
        print(" HIT!")
        defender.board_plain[r][c] = HIT
        defender.hits_taken += 1
        defender.board_enc[r][c] = HE.encryptInt(np.array([0], dtype=np.int64))
    else:
        print(" MISS!")
        defender.board_plain[r][c] = MISS